\chapter{Graphics Techniques}
\label{chap:graphics}

Speed of rendering is critical to the success of the method.  In order to perform in real time (~15-30fps), we have a limited amount of time with which to render our model and choose an accurate configuration.  The more we explore the parameter space, the more likely it is that we will find an accurate hand articulation to match the observation.  The accuracy of the result is therefore inversely proporsional to the speed that it takes to render a hand and so it is important for the success of the implementation that hand rendering is done optimally.

Modern GPUs have many driver extensions which allow some tasks to be very quickly.  We explore features which will allow for fast hand rendering.

Kyriazis gives a description of a GPU framework for model based inference~\cite{kyriazis2011}.  This section explores these suggestions and gives more detail of an OpenGL implementation.

Many code examples in this section are taken from the excellent tutorial by Etay
Meiri\~cite{ogldev:online}, although they are modified to make use of GLM.

\section{GL Maths Library}

The GL maths library (GLM) provides many linear algebraic functions for use with
OpenGL programs.  Constructors for typical graphical transformation matrices such as perspective
projection, rotation and transformation are provided.  Mathematical operations
are also implemented (And operators overloaded), allowing us to produce very
readable programs.

\section{Vertex Buffer Objects}
\label{sec:vbo}

Early OpenGL implementations provided glBegin and glEnd code blocks for rendering.

\begin{verbatim}

glBegin(GL_TRIANGLE)
  glVertex(-1.0f, -1.0f, 0.0f);
  glVertex(1.0f, -1.0f, 0.0f);
  glVertex(0.0f, 1.0f, 0.0f);
glEnd();

\end{verbatim}

This approach not only requires a function call for each vertex, but sends
information to the GPU with each call.  Newer implementations of OpenGL provide
vertex buffer objects (VBOs) which allow us to just send an array to the GPU
with a single function call.  This allows for much faster transfer of vertex
data to the GPU.  ACTLAAL shows example code of the same example.  Note that
the GPU will draw triangles as instructed by the \texttt{GL\_TRIANGLES} flag.  This
means that for every 3 vertices given in the array, a triangle is drawn.

\begin{verbatim}

glm::vec3 vertices[3];
vertices[0] = glm::vec3(-1.0f, -1.0f, 0.0f);
vertices[1] = glm::vec3(1.0f, -1.0f, 0.0f);
vertices[2] = glm::vec3(0.0f, 1.0f, 0.0f);

/* Some code to bind arrays */

glDrawArrays(GL_TRIANGLES, 0, 3);

\end{verbatim}

\section{Indexed rendering}

When using glDrawArrays, we specify how the vertices in the array will be
interpreted.  For \texttt{GL\_TRIANGLES}, every three vertices will represent a triangle.
For large triangular meshes, many vertices are shared within seperate triangles,
meaning many vertices will be duplicated in the vertex array.

To solve this we use indexed rendering.

Consider a tetrahedron.  Each vertex is shared by three triangles.  The original
VBO approach would lead to nine vertices being stored in the vertex array.
Using an indexed approach, we put 4 vertices in a vertex array, and create an
index array which specifies the index of the vertices in the vertex array which
correspond to the triangles.

\begin{verbatim}

glm::vec3 vertices[4];
vertices[0] = glm::vec3(-1.0f, -1.0f, 0.0f);
vertices[1] = glm::vec3(0.0f, -1.0f, 1.0f);
vertices[2] = glm::vec3(1.0f, -1.0f, 0.0f);
vertices[3] = glm::vec3(0.0f, 1.0f, 0.0f);

unsigned int indices[] = { 0, 3, 1,
                           1, 3, 2,
                           2, 3, 0,
                           0, 2, 1 };

/* Some code to bind arrays */

glDrawElements(GL_TRIANGLES, 12, GL_UNSIGNED_INT, 0);
\end{verbatim}

\section{Instanced Rendering}

The hand model we are using for this project is made of cylinders, cones, ellipsoids
and spheres in various configurations.  It is important to note that an
ellipsoid is just a sphere with a transformation applied to it, and similarly a
cone is a cylinder with a transformation applied.

Instanced rendering is a technology which allows us to send vertex information
about an object to the GPU once, but render it multiple times with a different
transformation applied to it.

This is important for our model, since a hand is just many transformed instances of a sphere
and cylinder.  To render a single hand, we require 17 transformed
spheres and 11 transformed cylinders (And since we are producing a large N-tiled
rendering, we require N times this).  Using instanced rendering, we can send the
vertex information for a single cylinder and sphere to the GPU, and send
pre-computed transformation matrices to the GPU for each instance.

\section{Tiled Rendering}

Producing a 

\section{Vertex Shaders}

\section{Pixel Shaders}

